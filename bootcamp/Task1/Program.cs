// Напишите программу, которая считает сумму чисел от 1 до n (1 и 3 тип алгоритма)

using System.Xml.XPath;

// Console.Write("Введите число: ");
// // функция int.Parse работает быстрее, чем  Convert.ToInt32
// int n = int.Parse(Console.ReadLine()!), result = 0; // функция не меняет ячейку, а заменяет данные в ней
// //int n = Convert.ToInt32(Console.ReadLine());// функция меняет ячейку и сохраняет данные в новой ячейке
// for(int i = 1; i <= n; i++) // цикл повторяется (n) раз => О(n)
//  result += i;
// System.Console.WriteLine($"Сумма чисел от 1 до {n} равна {result} ");

Console.Write("Введите чиисло: ");
int n = int.Parse(Console.ReadLine()!); // О(1)
// чтобы делилось корректно нужен double его можно добавить вместо int, а можно поставить 2,0
System.Console.WriteLine($"Сумма чисел от 1 до {n} равна {(1 + n) / 2.0 * n} ");

// Бинарный поиск (двоичный поиск) 2 ой тип алогитма
// Загаданное число равно 67
// Необходимо загадать число от 0 до 100 (надо будет делить на 2)
// Число больше 50? - да (значит число от 50 до 100) =>((100+50)/2)   (50/2)=>(25+50) 
// Число больше 75? - нет (от 50 до 75)
// Число больше 62? - да (от 62 до 75)
// Число больше 68? - нет (от 62 до 68)
// Число больше 65? - да (от 65 до 68)
// Число больше 66? - да (от 66 до 68)
// Число больше 67? - нет (Ответ: 67)
// 7 попыток
// Сложность алгоритма бинарного поиска равен O(log2(n))

// Быстрая сортировка О(n * log2(n)) (реккурсивный подход)

// необходимо отсортировть массив

// [34, -10, 23, 5, 2, 1]
// 1. Выбирается опорный элемент ( в основном берется первый элемент массива)
// 2. Создается 2 массива. 1-ый массив содержит элементы меньше опорного,
// 2-ой массив содержит элементы больше или равные опорному.

// Опорный элемент равен 34 рекурсия совершится и будет [1, 2, 5, 23, 34]
// [-10, 23, 5, 2, 1] + [34] + []
// Опорный элемент -10 рекурсия совершится и будет [-10, 1, 2, 5, 23]
// [] + [-10] + [23, 5, 2, 1]
// Опорный элемент 23 рекурсия совершится и будет [1, 2, 5, 23]
// [5, 2, 1] + [23] + []
// Опорный элемент 5 рекурсия совершится и будет [1, 2, 5]
//[2, 1] + [5] + []
// Опорный элемент 2
// [1] + [2] + []